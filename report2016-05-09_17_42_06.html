<!DOCTYPE html><html><head><title>Report</title><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.2/jquery.min.js"></script><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous"><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script></head><body class='container'><h1 align='center'>Report to CISO</h1><br><br><h3><b>CVE-2012-0997</b></h3><h4><b>Vendor:</b> 11in1</h4><h4><b>Product:</b>11in1</h4><h4><b>Version:</b>stable_12-31-2011</h4><button class="btn" type="button" data-toggle="collapse" data-target="#cveDetails0" aria-expanded="false" aria-controls="collapseExample">
Show cve details
</button>
<div class="collapse" id="cveDetails0">
<div class="well"><b>Impact</b><br><b>Availability: </b>PARTIAL<br><b>Confidentiality: </b>PARTIAL<br><b>Integrity: </b>PARTIAL<br><br><b>Access</b><br><b>Complexity: </b>MEDIUM<br><b>Authencitcation: </b> NONE<br><b>Vector: </b> NETWORK<br><b>CVSS: </b>6.8<br><b>CWE: </b>CWE-352<br><h3><b>Attack ways</b><br></h3><button class="btn" type="button" data-toggle="collapse" data-target="#attackWays0" aria-expanded="false" aria-controls="collapseExample">
Show attack ways
</button>
<div class="collapse" id="attackWays0">
<div class="well"><b>Name: </b>Cross-Domain Search Timing<br><b>Summary: </b><br>An attacker initiates cross domain HTTP / GET requests and times the server responses. The timing of these responses may leak important information on what is happening on the server. Browser's same origin policy prevents the attacker from directly reading the server responses (in the absence of any other weaknesses), but does not prevent the attacker from timing the responses to requests that the attacker issued cross domain.<br>For GET requests an attacker could for instance leverage the "img" tag in conjunction with "onload() / onerror()" javascript events. For the POST requests, an attacker could leverage the "iframe" element and leverage the "onload()" event. There is nothing in the current browser security model that prevents an attacker to use these methods to time responses to the attackers' cross domain requests.<br>The timing for these responses leaks information. For instance, if a victim has an active session with their online e-mail account, an attacker could issue search requests in the victim's mailbox. While the attacker is not able to view the responses, based on the timings of the responses, the attacker could ask yes / no questions as to the content of victim's e-mails, who the victim e-mailed, when, etc. This is but one example; There are other scenarios where an attacker could infer potentially sensitive information from cross domain requests by timing the responses while asking the right questions that leak information.<br><br><b>Solutions:</b><br>Design: The browser's security model could be fixed to not leak timing information for cross domain requests<br> <hr style='border-color: black;' width="50%" size="8" align="center"><b>Name: </b>Cross Site Identification<br><b>Summary: </b><br>An attacker harvests identifying information about a victim via an active session that the victim's browser has with a social networking site. A victim may have the social networking site open in one tab or perhaps is simply using the "remember me" feature to keep his or her session with the social networking site active. An attacker induces a payload to execute in the victim's browser that transparently to the victim initiates a request to the social networking site (e.g., via available social network site APIs) to retrieve identifying information about a victim. While some of this information may be public, the attacker is able to harvest this information in context and may use it for further attacks on the user (e.g., spear phishing).<br>In one example of an attack, an attacker may post a malicious posting that contains an image with an embedded link. The link actually requests identifying information from the social networking site. A victim who views the malicious posting in his or her browser will have sent identifying information to the attacker, as long as the victim had an active session with the social networking site. There are many other ways in which the attacker may get the payload to execute in the victim's browser mainly by finding a way to hide it in some reputable site that the victim visits. The attacker could also send the link to the victim in an e-mail and trick the victim into clicking on the link.<br>This attack is basically a cross site request forgery attack with two main differences. First, there is no action that is performed on behalf of the user aside from harvesting information. So standard CSRF protection may not work in this situation. Second, what is important in this attack pattern is the nature of the data being harvested, which is identifying information that can be obtained and used in context. This real time harvesting of identifying information can be used as a prelude for launching real time targeted social engineering attacks on the victim.<br><br><b>Solutions:</b><br>Usage: Users should not open other tabs in the browser when using a social networking site.<br> <hr style='border-color: black;' width="50%" size="8" align="center"><b>Name: </b>Cross Site Request Forgery (aka Session Riding)<br><b>Summary: </b><br>An attacker crafts malicious web links and distributes them (via web pages, email, etc.), typically in a targeted manner, hoping to induce users to click on the link and execute the malicious action against some third-party application. If successful, the action embedded in the malicious link will be processed and accepted by the targeted application with the users' privilege level.<br>This type of attack leverages the persistence and implicit trust placed in user session cookies by many web applications today. In such an architecture, once the user authenticates to an application and a session cookie is created on the user's system, all following transactions for that session are authenticated using that cookie including potential actions initiated by an attacker and simply "riding" the existing session cookie.<br><br><b>Solutions:</b><br>Use cryptographic tokens to associate a request with a specific action. The token can be regenerated at every request so that if a request with an invalid token is encountered, it can be reliably discarded. The token is considered invalid if it arrived with a request other than the action it was supposed to be associated with.<br>Although less reliable, the use of the optional HTTP Referrer header can also be used to determine whether an incoming request was actually one that the user is authorized for, in the current context.<br>Additionally, the user can also be prompted to confirm an action every time an action concerning potentially sensitive data is invoked. This way, even if the attacker manages to get the user to click on a malicious link and request the desired action, the user has a chance to recover by denying confirmation. This solution is also implicitly tied to using a second factor of authentication before performing such actions.<br>In general, every request must be checked for the appropriate authentication token as well as authorization in the current session context.<br> <hr style='border-color: black;' width="50%" size="8" align="center"><b>Name: </b>JSON Hijacking (aka JavaScript Hijacking)<br><b>Summary: </b><br>An attacker targets a system that uses JavaScript Object Notation (JSON) as a transport mechanism between the client and the server (common in Web 2.0 systems using AJAX) to steal possibly confidential information transmitted from the server back to the client inside the JSON object by taking advantage of the loophole in the browser's Same Origin Policy that does not prohibit JavaScript from one website to be included and executed in the context of another website.<br>An attacker gets the victim to visit his or her malicious page that contains a script tag whose source points to the vulnerable system with a URL that requests a response from the server containing a JSON object with possibly confidential information. The malicious page also contains malicious code to capture the JSON object returned by the server before any other processing on it can take place, typically by overriding the JavaScript function used to create new objects. This hook allows the malicious code to get access to the creation of each object and transmit the possibly sensitive contents of the captured JSON object to the attackers' server.<br>There is nothing in the browser's security model to prevent the attackers' malicious JavaScript code (originating from attacker's domain) to set up an environment (as described above) to intercept a JSON object response (coming from the vulnerable target system's domain), read its contents and transmit to the attackers' controlled site. The same origin policy protects the domain object model (DOM), but not the JSON.<br><br><b>Solutions:</b><br>Ensure that server side code can differentiate between legitimate requests and forged requests. The solution is similar to protection against Cross Site Request Forger (CSRF), which is to use a hard to guess random nonce (that is unique to the victim's session with the server) that the attacker has no way of knowing (at least in the absence of other weaknesses). Each request from the client to the server should contain this nonce and the server should reject all requests that do not contain the nonce.<br>On the client side, the system's design could make it difficult to get access to the JSON object content via the script tag. Since the JSON object is never assigned locally to a variable, it cannot be readily modified by the attacker before being used by a script tag. For instance, if while(1) was added to the beginning of the JavaScript returned by the server, trying to access it with a script tag would result in an infinite loop. On the other hand, legitimate client side code can remove the while(1) statement after which the JavaScript can be evaluated. A similar result can be achieved by surrounding the returned JavaScript with comment tags, or using other similar techniques (e.g. wrapping the JavaScript with HTML tags).<br>Make the URLs in the system used to retrieve JSON objects unpredictable and unique for each user session.<br>Ensure that to the extent possible, no sensitive data is passed from the server to the client via JSON objects. JavaScript was never intended to play that role, hence the same origin policy does not adequate address this scenario.<br> <hr style='border-color: black;' width="50%" size="8" align="center"></div></div><h3><b>CPEs</b><br></h3><button class="btn" type="button" data-toggle="collapse" data-target="#cpe0" aria-expanded="false" aria-controls="collapseExample">
Show attack ways
</button>
<div class="collapse" id="cpe0">
<div class="well">cpe:2.3:a:11in1:11in1:1.2.1:stable_12-31-2011<br>cpe:/a:11in1:11in1:1.2.1:stable_12-31-2011<br></div></div></div></div> <hr width="50%" size="8" align="center"><br><h3><b>CVE-2012-0996</b></h3><h4><b>Vendor:</b> 11in1</h4><h4><b>Product:</b>11in1</h4><h4><b>Version:</b>stable_12-31-2011</h4><button class="btn" type="button" data-toggle="collapse" data-target="#cveDetails1" aria-expanded="false" aria-controls="collapseExample">
Show cve details
</button>
<div class="collapse" id="cveDetails1">
<div class="well"><b>Impact</b><br><b>Availability: </b>NONE<br><b>Confidentiality: </b>PARTIAL<br><b>Integrity: </b>NONE<br><br><b>Access</b><br><b>Complexity: </b>LOW<br><b>Authencitcation: </b> NONE<br><b>Vector: </b> NETWORK<br><b>CVSS: </b>5.0<br><b>CWE: </b>CWE-22<br><h3><b>Attack ways</b><br></h3><button class="btn" type="button" data-toggle="collapse" data-target="#attackWays1" aria-expanded="false" aria-controls="collapseExample">
Show attack ways
</button>
<div class="collapse" id="attackWays1">
<div class="well"><b>Name: </b>Directory Traversal<br><b>Summary: </b><br>An attacker with access to file system resources, either directly or via application logic, will use various file path specification or navigation mechanisms such as ".." in path strings and absolute paths to extend their range of access to inappropriate areas of the file system. The attacker attempts to either explore the file system for recon purposes or access directories and files that are intended to be restricted from their access. Exploring the file system can be achieved through constructing paths presented to directory listing programs, such as "ls" and 'dir', or through specially crafted programs that attempt to explore the file system. The attacker engaging in this type of activity is searching for information that can be used later in a more exploitive attack. Access to restricted directories or files can be achieved through modification of path references utilized by system applications.<br><br><b>Solutions:</b><br>Design: Configure the access control correctly.<br>Design: Enforce principle of least privilege.<br>Design: Execute programs with constrained privileges, so parent process does not open up further vulnerabilities. Ensure that all directories, temporary directories and files, and memory are executing with limited privileges to protect against remote execution.<br>Design: Input validation. Assume that user inputs are malicious. Utilize strict type, character, and encoding enforcement.<br>Design: Proxy communication to host, so that communications are terminated at the proxy, sanitizing the requests before forwarding to server host.<br>Design: Run server interfaces with a non-root account and/or utilize chroot jails or other configuration techniques to constrain privileges even if attacker gains some limited access to commands.<br>Implementation: Host integrity monitoring for critical files, directories, and processes. The goal of host integrity monitoring is to be aware when a security issue has occurred so that incident response and other forensic activities can begin.<br>Implementation: Perform input validation for all remote content, including remote and user-generated content.<br>Implementation: Perform testing such as pen-testing and vulnerability scanning to identify directories, programs, and interfaces that grant direct access to executables.<br>Implementation: Use indirect references rather than actual file names.<br>Implementation: Use possible permissions on file access when developing and deploying web applications.<br>Implementation: Validate user input by only accepting known good. Ensure all content that is delivered to client is sanitized against an acceptable content specification -- whitelisting approach.<br> <hr style='border-color: black;' width="50%" size="8" align="center"><b>Name: </b>File System Function Injection, Content Based<br><b>Summary: </b><br>An attack of this type exploits the host's trust in executing remote content including binary files. The files are poisoned with a malicious payload (targeting the file systems accessible by the target software) by the attacker and may be passed through standard channels such as via email, and standard web content like PDF and multimedia files. The attacker exploits known vulnerabilities or handling routines in the target processes. Vulnerabilities of this type have been found in a wide variety of commercial applications from Microsoft Office to Adobe Acrobat and Apple Safari web browser. When the attacker knows the standard handling routines and can identify vulnerabilities and entry points they can be exploited by otherwise seemingly normal content. Once the attack is executed, the attackers' program can access relative directories such as C:\Program Files or other standard system directories to launch further attacks. In a worst case scenario, these programs are combined with other propagation logic and work as a virus.<br><br><b>Solutions:</b><br>Design: Enforce principle of least privilege<br>Design: Validate all input for content including files. Ensure that if files and remote content must be accepted that once accepted, they are placed in a sandbox type location so that lower assurance clients cannot write up to higher assurance processes (like Web server processes for example)<br>Design: Execute programs with constrained privileges, so parent process does not open up further vulnerabilities. Ensure that all directories, temporary directories and files, and memory are executing with limited privileges to protect against remote execution.<br>Design: Proxy communication to host, so that communications are terminated at the proxy, sanitizing the requests before forwarding to server host.<br>Implementation: Virus scanning on host<br>Implementation: Host integrity monitoring for critical files, directories, and processes. The goal of host integrity monitoring is to be aware when a security issue has occurred so that incident response and other forensic activities can begin.<br> <hr style='border-color: black;' width="50%" size="8" align="center"><b>Name: </b>Using Slashes and URL Encoding Combined to Bypass Validation Logic<br><b>Summary: </b><br>This attack targets the encoding of the URL combined with the encoding of the slash characters. An attacker can take advantage of the multiple way of encoding an URL and abuse the interpretation of the URL. An URL may contain special character that need special syntax handling in order to be interpreted. Special characters are represented using a percentage character followed by two digits representing the octet code of the original character (%HEX-CODE). For instance US-ASCII space character would be represented with %20. This is often referred as escaped ending or percent-encoding. Since the server decodes the URL from the requests, it may restrict the access to some URL paths by validating and filtering out the URL requests it received. An attacker will try to craft an URL with a sequence of special characters which once interpreted by the server will be equivalent to a forbidden URL. It can be difficult to protect against this attack since the URL can contain other format of encoding such as UTF-8 encoding, Unicode-encoding, etc.<br><br><b>Solutions:</b><br>Assume all input is malicious. Create a white list that defines all valid input to the software system based on the requirements specifications. Input that does not match against the white list should not be permitted to enter into the system. Test your decoding process against malicious input.<br>Be aware of the threat of alternative method of data encoding and obfuscation technique such as IP address encoding.<br>When client input is required from web-based forms, avoid using the "GET" method to submit data, as the method causes the form data to be appended to the URL and is easily manipulated. Instead, use the "POST method whenever possible.<br>Any security checks should occur after the data has been decoded and validated as correct data format. Do not repeat decoding process, if bad character are left after decoding process, treat the data as suspicious, and fail the validation process.<br>Refer to the RFCs to safely decode URL.<br>Regular expression can be used to match safe URL patterns. However, that may discard valid URL requests if the regular expression is too restrictive.<br>There are tools to scan HTTP requests to the server for valid URL such as URLScan from Microsoft (http://www.microsoft.com/technet/security/tools/urlscan.mspx).<br> <hr style='border-color: black;' width="50%" size="8" align="center"><b>Name: </b>Manipulating Input to File System Calls<br><b>Summary: </b><br>An attacker manipulates inputs to the target software which the target software passes to file system calls in the OS. The goal is to gain access to, and perhaps modify, areas of the file system that the target software did not intend to be accessible.<br><br><b>Solutions:</b><br>Design: Enforce principle of least privilege.<br>Design: Ensure all input is validated, and does not contain file system commands<br>Design: Run server interfaces with a non-root account and/or utilize chroot jails or other configuration techniques to constrain privileges even if attacker gains some limited access to commands.<br>Design: For interactive user applications, consider if direct file system interface is necessary, instead consider having the application proxy communication.<br>Implementation: Perform testing such as pen-testing and vulnerability scanning to identify directories, programs, and interfaces that grant direct access to executables.<br> <hr style='border-color: black;' width="50%" size="8" align="center"><b>Name: </b>Using Escaped Slashes in Alternate Encoding<br><b>Summary: </b><br>This attack targets the use of the backslash in alternate encoding. An attacker can provide a backslash as a leading character and causes a parser to believe that the next character is special. This is called an escape. By using that trick, the attacker tries to exploit alternate ways to encode the same character which leads to filter problems and opens avenues to attack.<br><br><b>Solutions:</b><br>Verify that the user-supplied data does not use backslash character to escape malicious characters.<br>Assume all input is malicious. Create a white list that defines all valid input to the software system based on the requirements specifications. Input that does not match against the white list should not be permitted to enter into the system.<br>Be aware of the threat of alternative method of data encoding.<br>Regular expressions can be used to filter out backslash. Make sure you decode before filtering and validating the untrusted input data.<br>In the case of path traversals, use the principle of least privilege when determining access rights to file systems. Do not allow users to access directories/files that they should not access.<br>Any security checks should occur after the data has been decoded and validated as correct data format. Do not repeat decoding process, if bad character are left after decoding process, treat the data as suspicious, and fail the validation process.<br>Avoid making decisions based on names of resources (e.g. files) if those resources can have alternate names.<br> <hr style='border-color: black;' width="50%" size="8" align="center"><b>Name: </b>Using Slashes in Alternate Encoding<br><b>Summary: </b><br>This attack targets the encoding of the Slash characters. An attacker would try to exploit common filtering problems related to the use of the slashes characters to gain access to resources on the target host. Directory-driven systems, such as file systems and databases, typically use the slash character to indicate traversal between directories or other container components. For murky historical reasons, PCs (and, as a result, Microsoft OSs) choose to use a backslash, whereas the UNIX world typically makes use of the forward slash. The schizophrenic result is that many MS-based systems are required to understand both forms of the slash. This gives the attacker many opportunities to discover and abuse a number of common filtering problems. The goal of this pattern is to discover server software that only applies filters to one version, but not the other.<br><br><b>Solutions:</b><br>Any security checks should occur after the data has been decoded and validated as correct data format. Do not repeat decoding process, if bad character are left after decoding process, treat the data as suspicious, and fail the validation process. Refer to the RFCs to safely decode URL.<br>When client input is required from web-based forms, avoid using the "GET" method to submit data, as the method causes the form data to be appended to the URL and is easily manipulated. Instead, use the "POST method whenever possible.<br>There are tools to scan HTTP requests to the server for valid URL such as URLScan from Microsoft (http://www.microsoft.com/technet/security/tools/urlscan.mspx)<br>Be aware of the threat of alternative method of data encoding and obfuscation technique such as IP address encoding. (See related guideline section)<br>Test your path decoding process against malicious input.<br>In the case of path traversals, use the principle of least privilege when determining access rights to file systems. Do not allow users to access directories/files that they should not access.<br>Assume all input is malicious. Create a white list that defines all valid input to the application based on the requirements specifications. Input that does not match against the white list should not be permitted to enter into the system.<br> <hr style='border-color: black;' width="50%" size="8" align="center"><b>Name: </b>Relative Path Traversal<br><b>Summary: </b><br>An attacker exploits a weakness in input validation on the target by supplying a specially constructed path utilizing dot and slash characters for the purpose of obtaining access to arbitrary files or resources. An attacker modifies a known path on the target in order to reach material that is not available through intended channels. These attacks normally involve adding additional path separators (/ or \) and/or dots (.), or encodings thereof, in various combinations in order to reach parent directories or entirely separate trees of the target's directory structure.<br><br><b>Solutions:</b><br>Design: Input validation. Assume that user inputs are malicious. Utilize strict type, character, and encoding enforcement<br>Implementation: Perform input validation for all remote content, including remote and user-generated content.<br>Implementation: Validate user input by only accepting known good. Ensure all content that is delivered to client is sanitized against an acceptable content specification -- whitelisting approach.<br>Implementation: Prefer working without user input when using file system calls<br>Implementation: Use indirect references rather than actual file names.<br>Implementation: Use possible permissions on file access when developing and deploying web applications.<br> <hr style='border-color: black;' width="50%" size="8" align="center"></div></div><h3><b>CPEs</b><br></h3><button class="btn" type="button" data-toggle="collapse" data-target="#cpe1" aria-expanded="false" aria-controls="collapseExample">
Show attack ways
</button>
<div class="collapse" id="cpe1">
<div class="well">cpe:2.3:a:11in1:11in1:1.2.1:stable_12-31-2011<br>cpe:/a:11in1:11in1:1.2.1:stable_12-31-2011<br></div></div></div></div> <hr width="50%" size="8" align="center"></body></html>
